---
title: Unit Test CH7
description: The Art of Unit Testing Third Edition v7
published: true
date: 2022-07-21T02:13:56.780Z
tags: unit test
editor: markdown
dateCreated: 2022-07-18T06:47:17.753Z
---

# CH7 Trustworthy Tests
> - 如何知道你信任一個測試
> - 偵測到不信任的失敗測試
> - 偵測到不信任的通過測試
> - 處理片狀的測試

- 可信任性 `Trustworthiness`：開發者會想跑可信任的測試，而且他們可以有信心接受測試結果。信任測試不會有 bugs，而且測試到對的東西
- 可維護性 `Maintainability`：不可維護的測試是一個夢魘，因為它們會破壞專案的排程，或它們在專案被放到更激進的排程中時可能會被邊緣化。開發者可能會停止維護，而且會花費很多時間修復測試，或者當主要產品程式碼異動時要非常頻繁異動測試
- 可閱讀性 `Readability`：測試不只需要好閱讀，也需要可以在測試出錯時好查出問題。沒有可閱讀性，另外兩個要素會失敗的很快，測試會變得難以維護，也會變的不信任因為無法理解他們

## 7.1 如何知道你信任一個測試
> How to know you trust a test

### 你可能不會信任一個測試
- 他失敗時你不擔心
- 他通過時你擔心
### 你可能會信任一個測試
- 他失敗時你擔心有什麼功能被破壞，你沒有接著認為測試有問題
- 他通過時你覺得很安心，覺得不需要去手動測試或除錯

## 7.2 為什麼測試會失敗以及他可以怎樣幫助我們
> Why Tests Fail (and how it can help us)

- 測試應該是因為一個好理由而失敗，一個在程式碼中沒有被發現的真實的 bug 

## 7.3 一個在程式碼中沒有被發現的真實的 bug (好事!)
> A real bug has been uncovered in the production code. (good!)
- 測試沒有過，因為程式碼中有 bug
- 這樣很好，這就是為什麼我們需要測試

## 7.4 多臭蟲(說謊)的測試
> Buggy (lying) test
- 測試失敗是因為測試有 bug
- 產品程式碼可能是正確的，但是測試本身可能有臭蟲所以導致測試失敗
- 有多臭蟲的測試是很危險的，因為測試中的臭蟲可能會導致測試通過，但可能會讓我們沒想有到到實際上應該發生了什麼事情

### 7.4.1 如何去辨識出多臭蟲(說謊)的測試
- 當你有一個失敗的測試時，你可能已經針對產品程式碼除錯，但無法找到任何臭蟲，此時應該要懷疑失敗的測試才對
- 當我們仔細去對測試除錯時，可能會發現：
	- 斷言到錯的事情或錯的出口點
  - 注入錯誤的值到進入點
  - 觸發到錯誤的進入點
  
### 7.4.2 當我們建立了一個多臭蟲的測試時可以做什麼事?
- 不要慌張
- 修復測試中的臭蟲
- 執行測試查看是否已經可以通過
- 當測試通過時不要開心的太早：
  - 1). 到產品程式碼並寫上一個很明顯的臭蟲，這應該要可以被新修復的測試抓取到
  - 2). 再次執行測試並確認是否失敗，若是成功則表示測試當中仍然有臭蟲，修復測試直到他可以找到產品的臭蟲，並確認現在是否失敗
  - 3). 測試因為產品程式碼的臭蟲而失敗，現在修復產品程式碼的臭蟲，並執行測試，他應該要能通過
  - 4). 若是測試通過，則表示完成了，可以提交程式碼
  - 5). 若是一樣失敗，則表示測試可能還有其他臭蟲，從 2). 開始重複執行
  
### 7.4.3 在未來減少或避免多臭蟲的測試
- 使用 TDD 模式開發
- 在一開始時測試應該要是失敗的(還沒有產品程式碼)，當產品程式碼寫出來讓測試通過時，測試應該要是通過的
- 當測試失敗時，我們在測試中找到臭蟲。當測試開始通過時，我們一樣在測試中找到臭蟲

### 7.4.4 在單元測試中要避免使用邏輯
- 在測試中有高機率有臭蟲增加的情況多半是有很多的邏輯在測試中
- 在測試中移除以下邏輯
  - switch, if, else
  - foreach, for, while loop
  - 聯集 `concatenation` ex：+
  - try-catch

### 7.4.5 在斷言中使用邏輯-增加動態預期值
```javascript
// trust.spec.js 
describe("makeGreeting", () => {
  it("returns correct greeting for name", () => {
    const name = "abc";
    const result = trust.makeGreeting(name);
    expect(result).toBe("hello" + name); // bug in the test - expected to fail
  });
});
```

```javascript
// trust.js
const makeGreeting = (name) => {
  return "hello" + name;
};
```

```javascript
// trust.spec.js
describe("makeGreeting", () => {
  it("returns correct greeting for name 2", () => {
    const result = trust.makeGreeting("abc");
    expect(result).toBe("hello abc");
  });
});
```

### 7.4.6 其他形式的邏輯
```javascript
// trust.js
const isName = (input) => {
  return input.split(" ").length === 2;
};
```

```javascript
// trust.spec.js
describe("isName", () => {
  const namesToTest = ["firstOnly", "first second", ""];

  it("correctly finds out if it is a name", () => {
    namesToTest.forEach((name) => {
      const result = trust.isName(name);
      if (name.includes(" ")) {
        expect(result).toBe(true);
      } else {
        expect(result).toBe(false);
      }
    });
  });
});
```
- 對陣列進行迴圈
- 因為值有不同的情況(是否還有空格"  ")，所以需要使用到 if-else
- 重複撰寫產品程式碼的邏輯
- 測試會很難命名，因為有很多不同的情況與預期的結果
- 測試會難以閱讀與理解
- 測試會難以被重新創造
- 測試會更加容易有 bug 或測試到錯誤的東西

### 7.4.7 甚至有更多的邏輯
- 邏輯可能不會只存在於測試當中，也有可能在測試協助方法，手寫假物件，測試工具類別中
- 每一個增加邏輯都會的地方，都會讓程式碼變得難以閱讀，且增加測試使用到的異動工具方法時可能會有 bug 的機會

## 7.5 過時的測試(當功能改變時)
> Out of Date test (feature changed)
- 一個測試會失敗，當他並不符合現在的功能被測試時
- 假設現在有一個登入功能，早期版本登入需要提供使用者名稱與密碼，在新板是使用雙重認證 `2-factor authentication`，現有的測試就會開始失敗，因為沒有提供正確的參數給登入函式

### 7.5.1 現在我們可以做什麼?
- 為了新功能改寫測試
- 為了新功能寫一個新的測試，並移除舊的測試，因為他變的不再重要

### 7.5.2 在未來避免或預防這種情況
- 東西改變了，不覺得不應該有過時的測試
- 我們將會處理測試的可維護性，還有他們如何處理應用的變化

## 7.6 有衝突的測試(與其他測試)
> Conflicting test (with another test)
- 有兩個測試，一個失敗一個通過，但是他們不能同時通過
- A 測試確認呼叫一個函式使用兩個參數會產生 3
- B 測試確認呼叫一個函式使用兩個同樣參數會產生 4

### 7.6.1 現在我們可以做什麼?
- 根本的關鍵是其中一個測試是不重要的，也代表著他需要被移除
- 哪一個需要被移除呢?這個問題需要去確認哪一個功能需要哪一個正確的預期結果

### 7.6.2 在未來避免這種情況
- 這是一個健康的動向，不需要避免

## 7.7 不穩定的測試
> Flaky Test

- 一個測試很容易失敗，即使產品程式碼沒有異動，沒有任何刺激的事情發生，一下子通過一下子失敗，我們會稱這種測試是不穩定的、脆弱的

## 7.8 在一個通過的測試中有一種虛假的信任感
> Smelling a false sense of trust in passing tests

- 測試即使通過也會降低信任感的情況
	- 沒有斷言
  - 無法理解測試
  - 單元測試與整合測試搞混(互相包含或不穩定的)
  - 測試中含有邏輯
  - 一直在變動的測試
  - 測試多個關注點

### 7.8.1 測試未斷言任何東西
- 幾個測試沒有斷言的情況：
	- 在一些呼叫的函式中可能有隱藏的斷言，若函式命名沒有解釋到這些，會產生閱讀上的問題
  - 有時候寫一個測試只是為了去確認程式不會拋出例外，這樣並不會有值產生
  ``` 
  expect(() => someFunction()).not.toThrow(error) 
  ```
- 這樣的測試盡量要少量，除了一些特別的情況
	- 有時候因為缺乏經驗而少寫了斷言，可考慮加上失蹤的斷言或移除沒有值的測試部分
  - 有時候會主動撰寫測試去達到想像測試覆蓋率 `test coverage` 目標

### 7.8.2 無法理解測試
- 測試有不好的名稱
- 測試太長或有錯綜複雜的程式碼
- 多個命名會造成混亂
- 測試有隱藏的邏輯或假設不是很容易理解
- 測試結果沒有結論，不是失敗或通過
- 測試訊息無法提供足夠的資訊

### 7.8.3 單元測試與整合測試搞混(不穩定的)
- 整合測試會比單元測試還要不穩定，因為整合測試需要更多的依賴
- 將整合測試與單元測試寫在不同的地方，這樣可以給開發者一個測試的和平區 `safe green zone`，包含沒有不穩定的快速的測試，他們可以知道從哪裡得到最新版的程式，並在和平區執行所有測試，而測試應該都會通過
- 若和平區中的測試未通過，開發者會需要更加擔心
- 這樣的分類額外的好處是可以更加經常執行單元測試，因為沒有執行整合測試

### 7.8.4 測試中含有邏輯
在 7.4 節有提到

### 7.8.5 測試多個關注點(進入點、出口點)
- 出口點：為工作單元單一結束結果，一個回傳值、一個系統狀態的改變、呼叫第三方
- 以下為一個函式，有兩個出口點，兩個需要注意的點，他們皆回傳一個值並在 callback 函式觸發一個傳遞
  ```javascript
  const trigger = (x, y, callback) => {
  callback("I'm triggered");
  return x + y;
	};
  ```
- 寫一個測試確認兩個出口點在同一個測試當中
  ```javascript
  describe("trigger", () => {
  	it("works", () => {
    	const callback = jest.fn();
    	const result = trigger(1, 2, callback);
    	expect(result).toBe(3);
    	expect(callback).toHaveBeenCalledWith("I'm triggered");
  	});
	});
  ```
- 測試多個會讓命名變的困難
- 當 expect(result).toBe(3); 執行失敗時，expect(callback).toHaveBeenCalledWith("I'm triggered"); 不會執行到
- 將測試拆分成兩個
  ```javascript
	describe("trigger", () => {
  	it("triggers a given callback", () => {
    	const callback = jest.fn();
    	trigger(1, 2, callback);
    	expect(callback).toHaveBeenCalledWith("I'm triggered");
  	});
 
  	it("sums up given values", () => {
    	const result = trigger(1, 2, jest.fn());
    	expect(result).toBe(3);
  	});
	});
	```
- 有時候在同一個測試中斷言多個東西是 OK 的，這裡有一個 makePerson 是去用一些特性去建立一個新的人
  ```javascript
  const makePerson = (x, y) => {
    return {
      name: x,
      age: y,
      type: "person",
    };
  };

  describe("makePerson", () => {
    it("createsperson given passed in values", () => {
      const result = makePerson("name", 1);
      expect(result.name).toBe("name");
      expect(result.age).toBe(1);
    });
  });
  ```
- 在此測試當中我們同時斷言名字跟年紀，因為他們是同一個關注點的一部分，當第一個斷言失敗的時候，我們不會考慮第二個斷言，因為可能在一開始建立人的時候就有問題了

### 7.8.6 一直在變動的測試
- 當你的測試使用現在的日期時間當作他的一部分執行或斷言，則當每一次測試執行時我們可以去請求，這將會是一個困難的測試
- 當一個測試的結果無法跟他的預期與結果相符合時，代表他們是不穩定的，如此一來會降低開發者對測試的信任度

## 7.9 處理不穩定的測試
> Dealing with Flaky Tests

- 不同層面的測試，此圖是基於在我們測試中真實使用的依賴

![Unit Test a diagram of the various levels of tests.png](http://192.168.25.60:8000/files/file_storage/c2037f3c.png)

- 在最底層，我們已經掌握了幾乎所有的依賴，不論是模擬他們或是藉由配置真實的在記憶體中執行(很像是模擬物件與虛設常式)
- 越往更層一點，我們的測試越擺脫更多的模擬物件與虛設常式，並開始跑在更多真實的依賴當中，像是資料庫、網路、配置等等。這表示我們可掌握的可動部分會越少，且可能改變我們預期的路徑，返回未能預期到的值或不能執行等等
- 在最高層，沒有任何假的依賴，測試的所有東西都是真的，包含第三方 services、安全性、網路層、配置，這種類型的測試通常需要設置一個最接近產品的環境，但不是真的產品環境
- 往越高層，我們應該要對程式碼有更高的信心，除非我們不信任測試結果。但不幸的是，越往高層，有更多的機率測試會是不穩定的，因為有很多可動的部分
- 我們或許會假設最底層的測試不應該有任何不穩定的情況，因為他們不應該有可動的部分造成不穩定性。通常我們會將可動部分往低層的測試擺放，這樣可以使用現在的日期時間、機器、網路、系統檔案去做模擬

### 7.9.1 偵測不穩定性
- 一個測試在所有第三方執行時失敗
- 一個測試在未知的次數中失敗
- 一個測試因為外部情況而失敗，像是網路、資料庫、其他 APIs 無法運作，環境配置等等

### 7.9.2 不穩定的測試需要更多的時間去執行與理解
- 測試使用的網路、系統檔案、線程都需要時間去執行
- 當測試失敗的時候就會花久一點的時間去除錯

### 7.9.3 當你發現不穩定的測試時可以怎麼做?
- 同意對組織是什麼樣的不穩定，例如不改變任何產品程式碼並以 10 為一組進行測試，計算所有沒有一致結果的測試(i.e 沒有失敗 10 次或沒有通過 10 次)
- 將任何可能會有不穩定性的測試放在一個特別的分類或資料夾內，如此才能將測試進行拆分
- 從隔離出來的測試中縮減並移除不穩定性
	- 1). 隔離 `Quarantine`：建議將所有不穩定的測試從常規建置當中移除，如此便不會製造干擾並將他們暫時隔離到一個小的管道
	- 2). 修復 `Fix`：可以藉由控制依賴來讓測試不再不穩定，例如他需要資料庫裡的資料，就在測試裡寫新增資料到資料庫，有時候修復一個測試不太可行，所以才會需要轉換
	- 3). 轉換 `Convert`：透過將測試轉換到低層一點的測試來消除不穩定性，例如模擬一個網路出口點而非使用真實的
	- 4). 刪除 `Kill`：有些過時或舊的測試應該適時的進行刪除，而不要陷入沉沒成本謬誤 `Sunk Cost Fallacy` 當中

### 7.9.4 在高層級測試當中避免不穩定性
- 回滾 `roll back` 任何已經給外部分享的資源的改變
- 不要依賴其他測試改變外部狀態
- 取得一些外部系統與依賴的控制
	-	1). 可以隨意的重新創造他們
	- 2). 可以創造假的他們，是可以控制的
	- 3). 可以創造測試並可以通過
- 若是一些低層的測試可以涵蓋那些方案，則可以移除那些高層的測試
- 將一些高層的測試轉換成一組組低層的測試










